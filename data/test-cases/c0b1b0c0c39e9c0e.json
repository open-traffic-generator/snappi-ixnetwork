{"uid":"c0b1b0c0c39e9c0e","name":"test_static_lag","historyId":"pytest:test_lag#test_static_lag","time":{"start":1768372946323,"stop":1768373172175,"duration":225852},"status":"failed","statusMessage":"Exception: Time out occurred while waiting for stats to be accumulated","statusTrace":"api = <snappi_ixnetwork.snappi_api.Api object at 0x7f80f98fe050>\nutils = <module 'utils' from '/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/tests/utils/__init__.py'>\n\n    def test_static_lag(api, utils):\n        \"\"\"Demonstrates the following:\n        1) Creating a lag comprised of multiple ports\n        2) Creating emulated devices over the lag\n        3) Creating traffic over the emulated devices that will transmit\n        traffic to a single rx port.\n    \n            TX LAG              DUT             RX\n            ------+         +---------+\n            port 1|         |\n            ..    | ------> |\n            port n|         |\n            ------+\n        \"\"\"\n        config = api.config()\n        p1, p2, p3, p4 = (\n            config.ports.port(name=\"txp1\", location=utils.settings.ports[0])\n            .port(name=\"txp2\", location=utils.settings.ports[1])\n            .port(name=\"rxp1\", location=utils.settings.ports[2])\n            .port(name=\"rxp2\", location=utils.settings.ports[3])\n        )\n    \n        config.layer1.layer1(\n            name=\"layer1\",\n            port_names=[p.name for p in config.ports],\n            speed=utils.settings.speed,\n            media=utils.settings.media,\n        )\n    \n        lag1, lag2 = config.lags.lag(name=\"lag1\").lag(name=\"lag2\")\n        lp1, lp2 = lag1.ports.port(port_name=p1.name).port(port_name=p2.name)\n        lp3, lp4 = lag2.ports.port(port_name=p3.name).port(port_name=p4.name)\n    \n        lag1.protocol.static.lag_id = 1\n        lag2.protocol.static.lag_id = 2\n    \n        lp1.ethernet.name, lp2.ethernet.name = \"eth1\", \"eth2\"\n        lp3.ethernet.name, lp4.ethernet.name = \"eth3\", \"eth4\"\n    \n        lp1.ethernet.mac = \"00:11:02:00:00:01\"\n        lp2.ethernet.mac = \"00:22:02:00:00:01\"\n        lp3.ethernet.mac = \"00:33:02:00:00:01\"\n        lp4.ethernet.mac = \"00:44:02:00:00:01\"\n    \n        lp1.ethernet.vlans.vlan(priority=1, name=\"vlan1\", id=1)[-1]\n        lp2.ethernet.vlans.vlan(priority=1, name=\"vlan2\", id=1)[-1]\n        lp3.ethernet.vlans.vlan(priority=1, name=\"vlan3\", id=1)[-1]\n        lp4.ethernet.vlans.vlan(priority=1, name=\"vlan4\", id=1)[-1]\n    \n        packets = 2000\n        f1_size = 74\n        f2_size = 1500\n        d1, d2 = config.devices.device(name=\"device1\").device(name=\"device2\")\n        eth1, eth2 = d1.ethernets.add(), d2.ethernets.add()\n        eth1.connection.port_name, eth2.connection.port_name = lag1.name, lag2.name\n        eth1.name, eth2.name = \"d_eth1\", \"d_eth2\"\n        eth1.mac, eth2.mac = \"00:00:00:00:00:11\", \"00:00:00:00:00:22\"\n        ip1, ip2 = eth1.ipv4_addresses.add(), eth2.ipv4_addresses.add()\n        ip1.name, ip2.name = \"ip1\", \"ip2\"\n        ip1.address = \"10.1.1.1\"\n        ip1.gateway = \"10.1.1.2\"\n        ip2.address = \"10.1.1.2\"\n        ip2.gateway = \"10.1.1.1\"\n        f1, f2 = config.flows.flow(name=\"f1\").flow(name=\"f2\")\n        f1.tx_rx.port.tx_name, f1.tx_rx.port.rx_name = p1.name, p2.name\n        f2.tx_rx.port.tx_name, f2.tx_rx.port.rx_name = p3.name, p4.name\n        config.options.port_options.location_preemption = True\n        f1.duration.fixed_packets.packets = packets\n        f2.duration.fixed_packets.packets = packets\n        f1.size.fixed = f1_size\n        f2.size.fixed = f2_size\n        f1.rate.percentage = 10\n        f2.rate.percentage = 10\n    \n        f1.metrics.enable = True\n        f1.metrics.loss = True\n    \n        f2.metrics.enable = True\n        f2.metrics.loss = True\n    \n        utils.start_traffic(api, config, start_capture=False)\n        utils.wait_for(lambda: utils.is_traffic_stopped(api), \"traffic to stop\")\n    \n>       utils.wait_for(\n            lambda: utils.is_stats_accumulated(api, packets * 2),\n            \"stats to be accumulated\",\n        )\n\ntests/test_lag.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfunc = <function test_static_lag.<locals>.<lambda> at 0x7f80f75c6710>\ncondition_str = 'stats to be accumulated', interval_seconds = 0.5\ntimeout_seconds = 30\n\n    def wait_for(func, condition_str, interval_seconds=None, timeout_seconds=None):\n        \"\"\"\n        Keeps calling the `func` until it returns true or `timeout_seconds` occurs\n        every `interval_seconds`. `condition_str` should be a constant string\n        implying the actual condition being tested.\n        Usage\n        -----\n        If we wanted to poll for current seconds to be divisible by `n`, we would\n        implement something similar to following:\n        ```\n        import time\n        def wait_for_seconds(n, **kwargs):\n            condition_str = 'seconds to be divisible by %d' % n\n            def condition_satisfied():\n                return int(time.time()) % n == 0\n            poll_until(condition_satisfied, condition_str, **kwargs)\n        ```\n        \"\"\"\n        if interval_seconds is None:\n            interval_seconds = settings.interval_seconds\n        if timeout_seconds is None:\n            timeout_seconds = settings.timeout_seconds\n        start_seconds = int(time.time())\n    \n        print(\"\\n\\nWaiting for %s ...\" % condition_str)\n        while True:\n            res = func()\n            if res:\n                print(\"Done waiting for %s\" % condition_str)\n                break\n            if res is None:\n                raise Exception(\"Wait aborted for %s\" % condition_str)\n            if timed_out(start_seconds, timeout_seconds):\n                msg = \"Time out occurred while waiting for %s\" % condition_str\n>               raise Exception(msg)\nE               Exception: Time out occurred while waiting for stats to be accumulated\n\ntests/utils/common.py:224: Exception","flaky":false,"newFailed":true,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"steps":[{"name":"--------------------------------- Captured Log ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"--------------------------------- Captured Out ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":3,"attachmentsCount":0,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"resultFormat","value":"junit"},{"name":"suite","value":"pytest"},{"name":"host","value":"snappi-ixn-ci-novus10g"},{"name":"testClass","value":"test_lag"},{"name":"package","value":"test_lag"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":27,"broken":0,"skipped":1,"passed":258,"unknown":0,"total":286},"items":[{"uid":"3f7b4aeac58b719f","status":"passed","time":{"start":1767873824411,"stop":1767874016941,"duration":192530}},{"uid":"e1f3dd067036a4cc","status":"passed","time":{"start":1767862092912,"stop":1767862288589,"duration":195677}},{"uid":"5d070185565f83a0","status":"passed","time":{"start":1767677129994,"stop":1767677320309,"duration":190315}},{"uid":"a9d8a932db23b50e","status":"passed","time":{"start":1765779386953,"stop":1765779585641,"duration":198688}},{"uid":"496a355e9ea6da5e","status":"passed","time":{"start":1765462253388,"stop":1765462446301,"duration":192913}},{"uid":"b1ec6d74e6700cf6","status":"passed","time":{"start":1765452139269,"stop":1765452331584,"duration":192315}},{"uid":"1511e90219a50222","status":"passed","time":{"start":1765442576325,"stop":1765442775699,"duration":199374}},{"uid":"9a9656cc4093fe8e","status":"passed","time":{"start":1765433708748,"stop":1765433917798,"duration":209050}},{"uid":"9c22142a65c6fc6b","status":"passed","time":{"start":1765424930744,"stop":1765425131475,"duration":200731}},{"uid":"8db05e769e79b12b","status":"passed","time":{"start":1765398148379,"stop":1765398346306,"duration":197927}},{"uid":"7c47e40bb9a93aec","status":"passed","time":{"start":1765388942440,"stop":1765389136267,"duration":193827}},{"uid":"fcb869c7023fff9a","status":"passed","time":{"start":1765380294965,"stop":1765380488585,"duration":193620}},{"uid":"d30974029ce1a671","status":"passed","time":{"start":1765371542819,"stop":1765371737790,"duration":194971}},{"uid":"7ec83dd5f1ac0c9e","status":"passed","time":{"start":1765362766459,"stop":1765362954142,"duration":187683}},{"uid":"eab54fd88b9ccceb","status":"passed","time":{"start":1764795769034,"stop":1764795966476,"duration":197442}},{"uid":"5617b8581d9d8816","status":"passed","time":{"start":1764786897413,"stop":1764787090946,"duration":193533}},{"uid":"8fab1a66713c3742","status":"passed","time":{"start":1764697223756,"stop":1764697416147,"duration":192391}},{"uid":"c2e3597f0fb0ecd0","status":"passed","time":{"start":1764688681148,"stop":1764688871224,"duration":190076}},{"uid":"c99589edd255726e","status":"passed","time":{"start":1764679168772,"stop":1764679358910,"duration":190138}},{"uid":"a262e3347653c84b","status":"passed","time":{"start":1764670230219,"stop":1764670427793,"duration":197574}}]},"tags":[]},"source":"c0b1b0c0c39e9c0e.json","parameterValues":[]}