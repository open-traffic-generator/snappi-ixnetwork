{"uid":"371036b39defa734","name":"test_encrypt","historyId":"pytest:macsec.test_macsec_stats#test_encrypt","time":{"start":1756135659955,"stop":1756135723638,"duration":63683},"status":"failed","statusMessage":"assert 4 == 2\n +  where 4 = len(<snappi.snappi.MacsecMetricIter object at 0x7fe228fde4c0>)\n +    where <snappi.snappi.MacsecMetricIter object at 0x7fe228fde4c0> = <snappi.snappi.MetricsResponse object at 0x7fe228fd9030>.macsec_metrics","statusTrace":"api = <snappi_ixnetwork.snappi_api.Api object at 0x7fe22a639720>\nb2b_raw_config = <snappi.snappi.Config object at 0x7fe2292439c0>\nutils = <module 'utils' from '/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/tests/utils/__init__.py'>\n\n    def test_encrypt(api, b2b_raw_config, utils):\n        \"\"\"\n        Test for the macsec configuration\n        \"\"\"\n        api.set_config(api.config())\n        b2b_raw_config.flows.clear()\n    \n        p1, p2 = b2b_raw_config.ports\n        d1, d2 = b2b_raw_config.devices.device(name=\"enc_only_macsec1\").device(\n            name=\"enc_only_macsec2\"\n        )\n    \n        eth1, eth2 = d1.ethernets.add(), d2.ethernets.add()\n        eth1.connection.port_name, eth2.connection.port_name = p1.name, p2.name\n        eth1.mac, eth2.mac = \"00:00:00:00:00:11\", \"00:00:00:00:00:22\"\n        ip1, ip2 = eth1.ipv4_addresses.add(), eth2.ipv4_addresses.add()\n        eth1.name, eth2.name = \"eth1\", \"eth2\"\n        ip1.name, ip2.name = \"ip1\", \"ip2\"\n    \n        macsec1, macsec2 = d1.macsec, d2.macsec\n        macsec1_int, macsec2_int = macsec1.ethernet_interfaces.add(), macsec2.ethernet_interfaces.add()\n        macsec1_int.eth_name, macsec2_int.eth_name = eth1.name, eth2.name\n        secy1, secy2 = macsec1_int.secure_entity, macsec2_int.secure_entity\n        secy1.name, secy2.name = \"macsec1\", \"macsec2\"\n    \n        # Data plane and crypto engine\n        secy1.data_plane.choice = secy2.data_plane.choice = \"encapsulation\"\n        secy1.data_plane.encapsulation.crypto_engine.choice = secy2.data_plane.encapsulation.crypto_engine.choice = \"encrypt_only\"\n        secy1_crypto_engine_enc_only, secy2_crypto_engine_enc_only = secy1.data_plane.encapsulation.crypto_engine.encrypt_only, secy2.data_plane.encapsulation.crypto_engine.encrypt_only\n    \n        # Data plane Tx SC PN\n        secy1_dataplane_txsc1, secy2_dataplane_txsc1 = secy1_crypto_engine_enc_only.secure_channels.add(), secy2_crypto_engine_enc_only.secure_channels.add()\n        secy1_dataplane_txsc1.tx_pn.choice = secy2_dataplane_txsc1.tx_pn.choice = \"fixed_pn\"\n        secy1_dataplane_txsc1.tx_pn.fixed.pn = secy2_dataplane_txsc1.tx_pn.fixed.pn = 100\n    \n        # static key\n        secy1_key_gen_proto, secy2_key_gen_proto = secy1.key_generation_protocol, secy2.key_generation_protocol\n        secy1_key_gen_proto.choice = secy2_key_gen_proto.choice = \"static_key\"\n        secy1_sk, secy2_sk = secy1_key_gen_proto.static_key, secy2_key_gen_proto.static_key\n        secy1_sk.cipher_suite = secy2_sk.cipher_suite = \"gcm_aes_xpn_128\"\n    \n        # Tx\n        secy1_tx, secy2_tx = secy1_sk.tx, secy2_sk.tx\n        secy1_txsc1, secy2_txsc1 = secy1_tx.secure_channels.add(), secy2_tx.secure_channels.add()\n    \n        # Tx SC end station\n        #secy1_txsc1.end_station = secy2_txsc1.end_station = True\n    \n        # Tx key\n        secy1_tx_sak1, secy2_tx_sak1 = secy1_txsc1.saks.add(), secy2_txsc1.saks.add()\n        #secy1_tx_sak1.sak = secy2_tx_sak1.sak = \"0xF123456789ABCDEF0123456789ABCDEF\"\n        secy1_tx_sak1.sak = secy2_tx_sak1.sak = \"f123456789abcdef0123456789abcdef\"\n        secy1_tx_sak1.ssci = secy2_tx_sak1.ssci = \"0000000a\"\n        secy1_tx_sak1.salt = secy2_tx_sak1.salt = \"00000000000000000000000b\"\n    \n        # Remaining Tx SC settings autofilled\n    \n        # Rx: Not required for stateless enryption only traffic\n        #secy1_rx, secy2_rx = secy1.rx, secy2.rx\n        #secy1_rxsc1, secy2_rxsc1 = secy1.rx.static_key.scs.add(), secy2.rx.static_key.scs.add()\n    \n        # Rx SC\n        #secy1_rxsc1.dut_system_id =  eth2.mac\n        #secy2_rxsc1.dut_system_id =  eth1.mac\n    \n        # Rx key\n        #secy1_rx_sak1, secy2_rx_sak1 = secy1_rxsc1.saks.add(), secy2_rxsc1.saks.add()\n        #secy1_rx_sak1.sak = secy2_rx_sak1.sak = \"0xF123456789ABCDEF0123456789ABCDEF\"\n        #secy1_rx_sak1.sak = secy2_rx_sak1.sak = \"f123456789abcdef0123456789abcdef\"\n    \n        # Remaining Rx SC settings autofilled\n    \n        # Gratuitous ARP is sent so that DUT can learn our IP. Grat ARP source/destination are local address\n        # DUT MAC needs to be configured manually stateless encyption only engine cannot decrypt any packet including DUT ARP\n    \n        ip1.address = \"10.1.1.1\"\n        ip2.address = \"10.1.1.2\"\n    \n        ip1.prefix = 24\n        ip2.prefix = 24\n    \n        ip1.gateway = ip2.address\n        ip2.gateway = ip1.address\n    \n        ip1.gateway_mac.choice = \"value\"\n        ip1.gateway_mac.value = eth2.mac\n    \n        ip2.gateway_mac.choice = \"value\"\n        ip2.gateway_mac.value = eth1.mac\n    \n        utils.start_traffic(api, b2b_raw_config)\n    \n        utils.wait_for(\n            lambda: results_ok(api), \"stats to be as expected\", timeout_seconds=30\n        )\n        enums = [\n            \"session_state\",\n            \"out_pkts_protected\",\n            \"out_pkts_encrypted\",\n            \"in_pkts_ok\",\n            \"in_pkts_bad\",\n            \"in_pkts_bad_tag\",\n            \"in_pkts_late\",\n            \"in_pkts_no_sci\",\n            \"in_pkts_not_using_sa\",\n            \"in_pkts_not_valid\",\n            \"in_pkts_unknown_sci\",\n            \"in_pkts_unused_sa\",\n            \"in_pkts_invalid\",\n            \"in_pkts_untagged\",\n            \"out_octets_protected\",\n            \"out_octets_encrypted\",\n            \"in_octets_validated\",\n            \"in_octets_decrypted\",\n        ]\n        expected_results = {\n            \"enc_only_macsec1\": [\"up\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            \"enc_only_macsec2\": [\"up\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        }\n        req = api.metrics_request()\n        req.macsec.secure_entity_names = [\"enc_only_macsec1\"]\n        results = api.get_metrics(req)\n        # assert len(results.macsec_metrics) == 2\n        assert results.macsec_metrics[0].name == \"enc_only_macsec1\"\n        print(f\"MACsec Result : enc_only_macsec1\")\n        for macsec_res in results.macsec_metrics:\n            for i, enum in enumerate(enums):\n                val = expected_results[macsec_res.name][i]\n                if \"session_state\" in enum:\n                    assert getattr(macsec_res, enum) == val\n                else:\n                    assert getattr(macsec_res, enum) >= val\n                print(f\"{enum} : {getattr(macsec_res, enum)}\")\n    \n        req = api.metrics_request()\n        req.macsec.secure_entity_names = [\"enc_only_macsec2\"]\n        results = api.get_metrics(req)\n    \n        # assert len(results.macsec_metrics) == 1\n        assert results.macsec_metrics[0].name == \"enc_only_macsec2\"\n        print(f\"MACsec Result : enc_only_macsec2\")\n        for macsec_res in results.macsec_metrics:\n            for i, enum in enumerate(enums):\n                val = expected_results[macsec_res.name][i]\n                if \"session_state\" in enum:\n                    assert getattr(macsec_res, enum) == val\n                else:\n                    assert getattr(macsec_res, enum) >= val\n                print(f\"{enum} : {getattr(macsec_res, enum)}\")\n    \n        req = api.metrics_request()\n        req.macsec.column_names = [\"session_state\"]\n        results = api.get_metrics(req)\n>       assert len(results.macsec_metrics) == 2\nE       assert 4 == 2\nE        +  where 4 = len(<snappi.snappi.MacsecMetricIter object at 0x7fe228fde4c0>)\nE        +    where <snappi.snappi.MacsecMetricIter object at 0x7fe228fde4c0> = <snappi.snappi.MetricsResponse object at 0x7fe228fd9030>.macsec_metrics\n\ntests/macsec/test_macsec_stats.py:159: AssertionError","flaky":false,"newFailed":true,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"steps":[{"name":"--------------------------------- Captured Log ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"--------------------------------- Captured Out ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":3,"attachmentsCount":0,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"resultFormat","value":"junit"},{"name":"suite","value":"pytest"},{"name":"host","value":"snappi-ixn-ci-novus10g"},{"name":"testClass","value":"macsec.test_macsec_stats"},{"name":"package","value":"macsec.test_macsec_stats"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":65,"broken":0,"skipped":1,"passed":94,"unknown":0,"total":160},"items":[{"uid":"1ec9b3e42b1a603b","status":"passed","time":{"start":1756112750540,"stop":1756112824179,"duration":73639}},{"uid":"c82d688f2a77526f","status":"passed","time":{"start":1756097345515,"stop":1756097418352,"duration":72837}},{"uid":"dbc4eddf659b2c1f","status":"passed","time":{"start":1755853618770,"stop":1755853701295,"duration":82525}},{"uid":"8f5da0591d58fa8d","status":"passed","time":{"start":1755770830114,"stop":1755770907292,"duration":77178}},{"uid":"7734456082e80c95","status":"passed","time":{"start":1755605594608,"stop":1755605657369,"duration":62761}},{"uid":"b91aa022b3d976ba","status":"passed","time":{"start":1755598268759,"stop":1755598335386,"duration":66627}},{"uid":"1b8f50d49ecf955f","status":"passed","time":{"start":1755590656281,"stop":1755590730611,"duration":74330}},{"uid":"1336d174dc44b5d9","status":"passed","time":{"start":1755582190551,"stop":1755582260039,"duration":69488}},{"uid":"7cb7984081b4eb0f","status":"passed","time":{"start":1755172446673,"stop":1755172524085,"duration":77412}},{"uid":"1850a809cda3d60e","status":"passed","time":{"start":1755152544019,"stop":1755152624558,"duration":80539}},{"uid":"7f19c2cc34d07072","status":"passed","time":{"start":1754658965828,"stop":1754659042518,"duration":76690}},{"uid":"3b42fb49c55ecb9f","status":"passed","time":{"start":1754630978584,"stop":1754631042403,"duration":63819}},{"uid":"b2bccc13ced800bb","status":"passed","time":{"start":1754558943969,"stop":1754559026454,"duration":82485}},{"uid":"7ff5522d6f688801","status":"passed","time":{"start":1754546458930,"stop":1754546530635,"duration":71705}},{"uid":"242da751cbc87ee8","status":"passed","time":{"start":1754506043870,"stop":1754506117041,"duration":73171}},{"uid":"49bcd42f912757f0","status":"passed","time":{"start":1754497549774,"stop":1754497630769,"duration":80995}},{"uid":"ff2e6ef18aa35c06","status":"passed","time":{"start":1754464142327,"stop":1754464227940,"duration":85613}},{"uid":"f11ba4426c81f4fb","status":"passed","time":{"start":1754456730779,"stop":1754456810053,"duration":79274}},{"uid":"49e7ff1a50e13714","status":"passed","time":{"start":1754377059323,"stop":1754377135482,"duration":76159}},{"uid":"90f3c20eb515a59a","status":"passed","time":{"start":1754345071017,"stop":1754345149047,"duration":78030}}]},"tags":[]},"source":"371036b39defa734.json","parameterValues":[]}