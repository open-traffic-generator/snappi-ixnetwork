{"uid":"481d662640012c77","name":"test_bgpv6_dual_stack_routes","historyId":"pytest:bgp.test_bgp_dual_stack#test_bgpv6_dual_stack_routes","time":{"start":1770209818625,"stop":1770210019226,"duration":200601},"status":"failed","statusMessage":"snappi_ixnetwork.exceptions.SnappiIxnException:   File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/snappi_api.py\", line 471, in set_control_state\n    event_names = self.ngpf.set_route_state(\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/device/ngpf.py\", line 333, in set_route_state\n    object_info = self.select_properties(xpath, properties=[active])\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/device/ngpf.py\", line 480, in select_properties\n    results = self.api._ixnetwork._connection._execute(url, payload)\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 308, in _execute\n    return self._send_recv(\"POST\", url, payload)\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 591, in _send_recv\n    return self._poll()\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 659, in _poll\n    return self._process_response_status_code(\n  File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 495, in _process_response_status_code\n    raise BadRequestError(message, response.status_code)\n  Args do not match signature","statusTrace":"self = <snappi_ixnetwork.snappi_api.Api object at 0x7fd20d0d62c0>\npayload = <snappi.snappi.ControlState object at 0x7fd20cef53a0>\n\n    def set_control_state(self, payload):\n        try:\n            control_option = payload.choice\n            control_obj = getattr(payload, control_option)\n            control_choice = control_obj.get(\"choice\")\n            request_payload = getattr(control_obj, control_choice)\n            self._connect()\n            event_names = []\n            event_state = None\n            event_type = control_choice\n            EventInfo = namedtuple(\n                \"EventInfo\", [\"event_type\", \"event_state\", \"event_names\"]\n            )\n            if control_option == \"port\":\n                if control_choice == \"capture\":\n                    self.capture.set_capture_state(request_payload)\n                elif control_choice == \"link\":\n                    self._TRIGGERED_EVENT = \"link\"\n                    if request_payload.port_names is not None:\n                        event_names = request_payload.port_names\n                        event_state = request_payload.state\n                    self.vport.set_link_state(request_payload)\n            elif control_option == \"protocol\":\n                if control_choice == \"all\":\n                    self.ngpf.set_protocol_state(request_payload)\n                elif control_choice == \"route\":\n                    event_state = request_payload.state\n                    with Timer(self, \"Setting route state\"):\n>                       event_names = self.ngpf.set_route_state(\n                            request_payload\n\nsnappi_ixnetwork/snappi_api.py:471: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsnappi_ixnetwork/device/ngpf.py:333: in set_route_state\n    object_info = self.select_properties(xpath, properties=[active])\nsnappi_ixnetwork/device/ngpf.py:480: in select_properties\n    results = self.api._ixnetwork._connection._execute(url, payload)\n.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py:308: in _execute\n    return self._send_recv(\"POST\", url, payload)\n.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py:591: in _send_recv\n    return self._poll()\n.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py:659: in _poll\n    return self._process_response_status_code(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ixnetwork_restpy.connection.Connection object at 0x7fd20cf1eb30>\nurl = None\nheaders = {'Connection': 'keep-alive', 'Content-Type': 'application/json', 'User-Agent': 'ixnetwork-restpy', 'X-Api-Key': '13c01b9d215c41bd9a49efc8580c3e56', ...}\nresponse = <Response [400]>\nasync_status = {'executionTimeMs': 0.0, 'id': '', 'message': None, 'progress': 100, ...}\n\n    def _process_response_status_code(self, url, headers, response, async_status=False):\n        errors = []\n        # add the initial error\n        if async_status is True:\n            async_status = response.json()\n            if (\n                \"message\" in async_status\n                and async_status[\"message\"] is not None\n                and \"API CONTENTION\" in async_status[\"message\"]\n            ):\n                response.status_code = 409\n            else:\n                response.status_code = 400\n            error = \"\"\n            if \"message\" in async_status and async_status[\"message\"] is not None:\n                error += \" \" + async_status[\"message\"]\n            if \"result\" in async_status and async_status[\"result\"] is not None:\n                error += \" \" + async_status[\"result\"]\n            errors.append(error)\n        else:\n            try:\n                for error in response.json()[\"errors\"]:\n                    errors.append(error[\"detail\"])\n            except:\n                errors.append(response.text)\n        # add any /globals/appErrors/error items\n        try:\n            preamble = url[\n                0 : url.find(\"/\", url.find(\"/sessions/\") + len(\"/sessions/\"))\n            ]\n            url = preamble + \"/ixnetwork/globals/appErrors/error\"\n            self._print_request(\"GET\", url)\n            error_response = self._session.request(\n                \"GET\",\n                url,\n                headers=headers,\n                verify=self._verify_cert,\n                allow_redirects=False,\n            )\n            server_info = \"\\tCurrent Server Errors/Warnings:\"\n            for error in error_response.json():\n                if error[\"errorLevel\"] in [\"kError\", \"kWarning\"]:\n                    if server_info is not None:\n                        errors.append(server_info)\n                        server_info = None\n                    errors.append(\n                        \"\\t%s [%s] [%s] %s\"\n                        % (\n                            error[\"lastModified\"],\n                            error[\"errorLevel\"][1:].upper(),\n                            error[\"name\"],\n                            error[\"description\"],\n                        )\n                    )\n        except:\n            pass\n        # raise the appropriate error\n        message = \"\\n\".join(errors)\n        logging.getLogger(__name__).debug(message)\n        if response.status_code == 400:\n>           raise BadRequestError(message, response.status_code)\nE           ixnetwork_restpy.errors.BadRequestError:  Args do not match signature\n\n.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py:495: BadRequestError\n\nDuring handling of the above exception, another exception occurred:\n\napi = <snappi_ixnetwork.snappi_api.Api object at 0x7fd20d0d62c0>\nb2b_raw_config = <snappi.snappi.Config object at 0x7fd20cdbff60>\nutils = <module 'utils' from '/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/tests/utils/__init__.py'>\n\n    def test_bgpv6_dual_stack_routes(api, b2b_raw_config, utils):\n        \"\"\"\n        Test for dual stack BGP configuration with both BGPv4 and BGPv6 sessions\n    \n        This demonstrates:\n        - Ethernet with both IPv4 and IPv6 addresses (dual stack)\n        - Separate BGPv4 session over IPv4 transport\n        - Separate BGPv6 session over IPv6 transport\n        - IPv4 routes advertised over BGPv4 session\n        - IPv6 routes advertised over BGPv6 session\n        - Traffic validation for both address families\n        \"\"\"\n        size = 1500\n        packets = 1000\n        api.set_config(api.config())\n        b2b_raw_config.flows.clear()\n    \n        # convergence config\n        b2b_raw_config.events.cp_events.enable = True\n        b2b_raw_config.events.dp_events.enable = True\n        b2b_raw_config.events.dp_events.rx_rate_threshold = 90\n    \n        # Configure ports and devices\n        p1, p2 = b2b_raw_config.ports\n        d1, d2 = b2b_raw_config.devices.device(name=\"tx_bgp\").device(name=\"rx_bgp\")\n    \n        # Configure Ethernet interfaces\n        eth1, eth2 = d1.ethernets.add(), d2.ethernets.add()\n        eth1.connection.port_name, eth2.connection.port_name = p1.name, p2.name\n        eth1.mac, eth2.mac = \"00:00:00:00:00:11\", \"00:00:00:00:00:22\"\n        eth1.name, eth2.name = \"eth1\", \"eth2\"\n    \n        # Configure IPv4 addresses (dual stack - layer 1)\n        ipv4_1, ipv4_2 = eth1.ipv4_addresses.add(), eth2.ipv4_addresses.add()\n        ipv4_1.name, ipv4_2.name = \"ipv4_1\", \"ipv4_2\"\n        ipv4_1.address = \"10.1.1.1\"\n        ipv4_1.gateway = \"10.1.1.2\"\n        ipv4_1.prefix = 24\n    \n        ipv4_2.address = \"10.1.1.2\"\n        ipv4_2.gateway = \"10.1.1.1\"\n        ipv4_2.prefix = 24\n    \n        # Configure IPv6 addresses (dual stack - layer 2)\n        ipv6_1, ipv6_2 = eth1.ipv6_addresses.add(), eth2.ipv6_addresses.add()\n        ipv6_1.name, ipv6_2.name = \"ipv6_1\", \"ipv6_2\"\n        ipv6_1.address = \"2000::1\"\n        ipv6_1.gateway = \"2000::2\"\n        ipv6_1.prefix = 64\n    \n        ipv6_2.address = \"2000::2\"\n        ipv6_2.gateway = \"2000::1\"\n        ipv6_2.prefix = 64\n    \n        # Configure BGP routers\n        bgp1, bgp2 = d1.bgp, d2.bgp\n        bgp1.router_id, bgp2.router_id = \"192.0.0.1\", \"192.0.0.2\"\n    \n        # Configure BGPv4 session over IPv4 interface\n        bgp1_ipv4_int, bgp2_ipv4_int = bgp1.ipv4_interfaces.add(), bgp2.ipv4_interfaces.add()\n        bgp1_ipv4_int.ipv4_name, bgp2_ipv4_int.ipv4_name = ipv4_1.name, ipv4_2.name\n    \n        # Configure BGPv4 peers\n        bgp1_v4_peer, bgp2_v4_peer = bgp1_ipv4_int.peers.add(), bgp2_ipv4_int.peers.add()\n        bgp1_v4_peer.name, bgp2_v4_peer.name = \"bgpv4_peer1\", \"bgpv4_peer2\"\n    \n        bgp1_v4_peer.peer_address = \"10.1.1.2\"\n        bgp1_v4_peer.as_type = \"ibgp\"\n        bgp1_v4_peer.as_number = 65001\n    \n        bgp2_v4_peer.peer_address = \"10.1.1.1\"\n        bgp2_v4_peer.as_type = \"ibgp\"\n        bgp2_v4_peer.as_number = 65001\n    \n        # Configure BGPv6 session over IPv6 interface\n        bgp1_ipv6_int, bgp2_ipv6_int = bgp1.ipv6_interfaces.add(), bgp2.ipv6_interfaces.add()\n        bgp1_ipv6_int.ipv6_name, bgp2_ipv6_int.ipv6_name = ipv6_1.name, ipv6_2.name\n    \n        # Configure BGPv6 peers\n        bgp1_v6_peer, bgp2_v6_peer = bgp1_ipv6_int.peers.add(), bgp2_ipv6_int.peers.add()\n        bgp1_v6_peer.name, bgp2_v6_peer.name = \"bgpv6_peer1\", \"bgpv6_peer2\"\n    \n        bgp1_v6_peer.peer_address = \"2000::2\"\n        bgp1_v6_peer.as_type = \"ibgp\"\n        bgp1_v6_peer.as_number = 65001\n    \n        bgp2_v6_peer.peer_address = \"2000::1\"\n        bgp2_v6_peer.as_type = \"ibgp\"\n        bgp2_v6_peer.as_number = 65001\n    \n        # Configure IPv4 route ranges over BGPv4 session\n        bgp1_v4_route = bgp1_v4_peer.v4_routes.add(name=\"bgp1_v4_routes\")\n        bgp2_v4_route = bgp2_v4_peer.v4_routes.add(name=\"bgp2_v4_routes\")\n    \n        bgp1_v4_route.addresses.add(address=\"100.1.1.1\", prefix=32, count=10, step=1)\n        bgp2_v4_route.addresses.add(address=\"200.1.1.1\", prefix=32, count=10, step=1)\n    \n        # Configure IPv6 route ranges over BGPv6 session\n        bgp1_v6_route = bgp1_v6_peer.v6_routes.add(name=\"bgp1_v6_routes\")\n        bgp2_v6_route = bgp2_v6_peer.v6_routes.add(name=\"bgp2_v6_routes\")\n    \n        bgp1_v6_route.addresses.add(address=\"3000::1\", prefix=128, count=10, step=1)\n        bgp2_v6_route.addresses.add(address=\"4000::1\", prefix=128, count=10, step=1)\n    \n    \n        # Configure traffic flow for IPv4 routes (over BGPv4 session)\n        flow_v4 = b2b_raw_config.flows.flow(name=\"flow_bgpv4\")[-1]\n        flow_v4.rate.percentage = 50\n        flow_v4.size.fixed = size\n        flow_v4.tx_rx.device.tx_names = [bgp1_v4_route.name]\n        flow_v4.tx_rx.device.rx_names = [bgp2_v4_route.name]\n        flow_v4.metrics.enable = True\n    \n        # Configure traffic flow for IPv6 routes (over BGPv6 session)\n        flow_v6 = b2b_raw_config.flows.flow(name=\"flow_bgpv6\")[-1]\n        flow_v6.rate.percentage = 50\n        flow_v6.size.fixed = size\n        flow_v6.tx_rx.device.tx_names = [bgp1_v6_route.name]\n        flow_v6.tx_rx.device.rx_names = [bgp2_v6_route.name]\n        flow_v6.metrics.enable = True\n    \n        # Apply configuration\n        api.set_config(b2b_raw_config)\n    \n        print(\"Starting all protocols ...\")\n        ps = api.control_state()\n        ps.choice = ps.PROTOCOL\n        ps.protocol.choice = ps.protocol.ALL\n        ps.protocol.all.state = ps.protocol.all.START\n        res = api.set_control_state(ps)\n        if len(res.warnings) > 0:\n            print(\"Warnings: {}\".format(res.warnings))\n    \n        # Start traffic\n        cs = api.control_state()\n        cs.choice = cs.TRAFFIC\n        cs.traffic.choice = cs.traffic.FLOW_TRANSMIT\n        cs.traffic.flow_transmit.state = cs.traffic.flow_transmit.START\n        res = api.set_control_state(cs)\n        if len(res.warnings) > 0:\n            print(\"Warnings: {}\".format(res.warnings))\n    \n        # Wait for traffic to reach configured line rate\n        utils.wait_for(\n            lambda: utils.is_traffic_running(api), \"traffic in started state\"\n        )\n    \n        # Wait for traffic to reach configured line rate\n        utils.wait_for(\n            lambda: utils.is_traffic_running(api), \"traffic in started state\"\n        )\n    \n        # Port Metrics\n        req = api.metrics_request()\n        req.port.port_names = []\n        port_metrics = api.get_metrics(req).port_metrics\n        utils.print_stats(port_stats=port_metrics)\n    \n        # Flow Metrics\n        req = api.metrics_request()\n        req.flow.flow_names = []\n        flow_metrics = api.get_metrics(req).flow_metrics\n        utils.print_stats(flow_stats=flow_metrics)\n    \n        # BGPv4 metrics\n        req = api.metrics_request()\n        req.bgpv4.peer_names = []\n        bgpv4_metrics = api.get_metrics(req).bgpv4_metrics\n        utils.print_stats(bgpv4_stats=bgpv4_metrics)\n    \n        # Validate all BGPv4 sessions are up\n        for bgp_metric in bgpv4_metrics:\n            assert bgp_metric.session_state == \"up\"\n    \n        # BGPv6 metrics\n        req = api.metrics_request()\n        req.bgpv6.peer_names = []\n        bgpv6_metrics = api.get_metrics(req).bgpv6_metrics\n        utils.print_stats(bgpv6_stats=bgpv6_metrics)\n    \n        # Validate all BGPv6 sessions are up\n        for bgp_metric in bgpv6_metrics:\n            assert bgp_metric.session_state == \"up\"\n    \n        # Withdraw routes from primary path\n        cs = api.control_state()\n        cs.protocol.route.names = [\"bgp2_v6_routes\"]\n        cs.protocol.route.state = cs.protocol.route.WITHDRAW\n>       res = api.set_control_state(cs)\n\ntests/bgp/test_bgp_dual_stack.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <snappi_ixnetwork.snappi_api.Api object at 0x7fd20d0d62c0>\npayload = <snappi.snappi.ControlState object at 0x7fd20cef53a0>\n\n    def set_control_state(self, payload):\n        try:\n            control_option = payload.choice\n            control_obj = getattr(payload, control_option)\n            control_choice = control_obj.get(\"choice\")\n            request_payload = getattr(control_obj, control_choice)\n            self._connect()\n            event_names = []\n            event_state = None\n            event_type = control_choice\n            EventInfo = namedtuple(\n                \"EventInfo\", [\"event_type\", \"event_state\", \"event_names\"]\n            )\n            if control_option == \"port\":\n                if control_choice == \"capture\":\n                    self.capture.set_capture_state(request_payload)\n                elif control_choice == \"link\":\n                    self._TRIGGERED_EVENT = \"link\"\n                    if request_payload.port_names is not None:\n                        event_names = request_payload.port_names\n                        event_state = request_payload.state\n                    self.vport.set_link_state(request_payload)\n            elif control_option == \"protocol\":\n                if control_choice == \"all\":\n                    self.ngpf.set_protocol_state(request_payload)\n                elif control_choice == \"route\":\n                    event_state = request_payload.state\n                    with Timer(self, \"Setting route state\"):\n                        event_names = self.ngpf.set_route_state(\n                            request_payload\n                        )\n                elif control_choice == \"lacp\":\n                    self.ngpf.set_device_state(request_payload)\n            elif control_option == \"traffic\":\n                self.traffic_item.transmit(request_payload)\n            elif control_option is not None:\n                msg = \"{} is not a supported choice for metrics; \\\n                the supported choices are \\\n                ['port', 'protocol', traffic]\".format(\n                    control_option\n                )\n                raise SnappiIxnException(400, msg)\n            self._event_info = EventInfo(event_type, event_state, event_names)\n        except Exception as err:\n>           raise SnappiIxnException(err)\nE           snappi_ixnetwork.exceptions.SnappiIxnException:   File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/snappi_api.py\", line 471, in set_control_state\nE               event_names = self.ngpf.set_route_state(\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/device/ngpf.py\", line 333, in set_route_state\nE               object_info = self.select_properties(xpath, properties=[active])\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/snappi_ixnetwork/device/ngpf.py\", line 480, in select_properties\nE               results = self.api._ixnetwork._connection._execute(url, payload)\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 308, in _execute\nE               return self._send_recv(\"POST\", url, payload)\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 591, in _send_recv\nE               return self._poll()\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 659, in _poll\nE               return self._process_response_status_code(\nE             File \"/home/github-runner/actions-runner/_work/snappi-ixnetwork/snappi-ixnetwork/.env/lib/python3.10/site-packages/ixnetwork_restpy/connection.py\", line 495, in _process_response_status_code\nE               raise BadRequestError(message, response.status_code)\nE             Args do not match signature\n\nsnappi_ixnetwork/snappi_api.py:487: SnappiIxnException","flaky":false,"newFailed":true,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"steps":[{"name":"--------------------------------- Captured Log ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"WARNING  root:snappi_api.py:1522 tx connectedLinkDown","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"WARNING  root:snappi_api.py:1522 rx connectedLinkDown","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"--------------------------------- Captured Out ---------------------------------","time":{},"steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":4,"attachmentsCount":0,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"resultFormat","value":"junit"},{"name":"suite","value":"pytest"},{"name":"host","value":"snappi-ixn-ci-novus10g"},{"name":"testClass","value":"bgp.test_bgp_dual_stack"},{"name":"package","value":"bgp.test_bgp_dual_stack"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":1,"broken":0,"skipped":0,"passed":1,"unknown":0,"total":2},"items":[{"uid":"b73bc3577ba3e0b8","status":"passed","time":{"start":1770191080383,"stop":1770191301453,"duration":221070}}]},"tags":[]},"source":"481d662640012c77.json","parameterValues":[]}